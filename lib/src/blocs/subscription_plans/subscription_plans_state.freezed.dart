// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'subscription_plans_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$SubscriptionPlansStateTearOff {
  const _$SubscriptionPlansStateTearOff();

  SubscriptionPlansInitial subscriptionPlansInitial() {
    return const SubscriptionPlansInitial();
  }

  SubscriptionPlansLoading subscriptionPlansLoading() {
    return const SubscriptionPlansLoading();
  }

  SubscriptionPlansLoaded subscriptionPlansLoaded(
      {required List<SubscriptionPlan> subscriptionPlans}) {
    return SubscriptionPlansLoaded(
      subscriptionPlans: subscriptionPlans,
    );
  }

  SubscriptionPlansEmpty subscriptionPlansEmpty() {
    return const SubscriptionPlansEmpty();
  }
}

/// @nodoc
const $SubscriptionPlansState = _$SubscriptionPlansStateTearOff();

/// @nodoc
mixin _$SubscriptionPlansState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() subscriptionPlansInitial,
    required TResult Function() subscriptionPlansLoading,
    required TResult Function(List<SubscriptionPlan> subscriptionPlans)
        subscriptionPlansLoaded,
    required TResult Function() subscriptionPlansEmpty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? subscriptionPlansInitial,
    TResult Function()? subscriptionPlansLoading,
    TResult Function(List<SubscriptionPlan> subscriptionPlans)?
        subscriptionPlansLoaded,
    TResult Function()? subscriptionPlansEmpty,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubscriptionPlansInitial value)
        subscriptionPlansInitial,
    required TResult Function(SubscriptionPlansLoading value)
        subscriptionPlansLoading,
    required TResult Function(SubscriptionPlansLoaded value)
        subscriptionPlansLoaded,
    required TResult Function(SubscriptionPlansEmpty value)
        subscriptionPlansEmpty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubscriptionPlansInitial value)? subscriptionPlansInitial,
    TResult Function(SubscriptionPlansLoading value)? subscriptionPlansLoading,
    TResult Function(SubscriptionPlansLoaded value)? subscriptionPlansLoaded,
    TResult Function(SubscriptionPlansEmpty value)? subscriptionPlansEmpty,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubscriptionPlansStateCopyWith<$Res> {
  factory $SubscriptionPlansStateCopyWith(SubscriptionPlansState value,
          $Res Function(SubscriptionPlansState) then) =
      _$SubscriptionPlansStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$SubscriptionPlansStateCopyWithImpl<$Res>
    implements $SubscriptionPlansStateCopyWith<$Res> {
  _$SubscriptionPlansStateCopyWithImpl(this._value, this._then);

  final SubscriptionPlansState _value;
  // ignore: unused_field
  final $Res Function(SubscriptionPlansState) _then;
}

/// @nodoc
abstract class $SubscriptionPlansInitialCopyWith<$Res> {
  factory $SubscriptionPlansInitialCopyWith(SubscriptionPlansInitial value,
          $Res Function(SubscriptionPlansInitial) then) =
      _$SubscriptionPlansInitialCopyWithImpl<$Res>;
}

/// @nodoc
class _$SubscriptionPlansInitialCopyWithImpl<$Res>
    extends _$SubscriptionPlansStateCopyWithImpl<$Res>
    implements $SubscriptionPlansInitialCopyWith<$Res> {
  _$SubscriptionPlansInitialCopyWithImpl(SubscriptionPlansInitial _value,
      $Res Function(SubscriptionPlansInitial) _then)
      : super(_value, (v) => _then(v as SubscriptionPlansInitial));

  @override
  SubscriptionPlansInitial get _value =>
      super._value as SubscriptionPlansInitial;
}

/// @nodoc

class _$SubscriptionPlansInitial
    with DiagnosticableTreeMixin
    implements SubscriptionPlansInitial {
  const _$SubscriptionPlansInitial();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SubscriptionPlansState.subscriptionPlansInitial()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'SubscriptionPlansState.subscriptionPlansInitial'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SubscriptionPlansInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() subscriptionPlansInitial,
    required TResult Function() subscriptionPlansLoading,
    required TResult Function(List<SubscriptionPlan> subscriptionPlans)
        subscriptionPlansLoaded,
    required TResult Function() subscriptionPlansEmpty,
  }) {
    return subscriptionPlansInitial();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? subscriptionPlansInitial,
    TResult Function()? subscriptionPlansLoading,
    TResult Function(List<SubscriptionPlan> subscriptionPlans)?
        subscriptionPlansLoaded,
    TResult Function()? subscriptionPlansEmpty,
    required TResult orElse(),
  }) {
    if (subscriptionPlansInitial != null) {
      return subscriptionPlansInitial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubscriptionPlansInitial value)
        subscriptionPlansInitial,
    required TResult Function(SubscriptionPlansLoading value)
        subscriptionPlansLoading,
    required TResult Function(SubscriptionPlansLoaded value)
        subscriptionPlansLoaded,
    required TResult Function(SubscriptionPlansEmpty value)
        subscriptionPlansEmpty,
  }) {
    return subscriptionPlansInitial(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubscriptionPlansInitial value)? subscriptionPlansInitial,
    TResult Function(SubscriptionPlansLoading value)? subscriptionPlansLoading,
    TResult Function(SubscriptionPlansLoaded value)? subscriptionPlansLoaded,
    TResult Function(SubscriptionPlansEmpty value)? subscriptionPlansEmpty,
    required TResult orElse(),
  }) {
    if (subscriptionPlansInitial != null) {
      return subscriptionPlansInitial(this);
    }
    return orElse();
  }
}

abstract class SubscriptionPlansInitial implements SubscriptionPlansState {
  const factory SubscriptionPlansInitial() = _$SubscriptionPlansInitial;
}

/// @nodoc
abstract class $SubscriptionPlansLoadingCopyWith<$Res> {
  factory $SubscriptionPlansLoadingCopyWith(SubscriptionPlansLoading value,
          $Res Function(SubscriptionPlansLoading) then) =
      _$SubscriptionPlansLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class _$SubscriptionPlansLoadingCopyWithImpl<$Res>
    extends _$SubscriptionPlansStateCopyWithImpl<$Res>
    implements $SubscriptionPlansLoadingCopyWith<$Res> {
  _$SubscriptionPlansLoadingCopyWithImpl(SubscriptionPlansLoading _value,
      $Res Function(SubscriptionPlansLoading) _then)
      : super(_value, (v) => _then(v as SubscriptionPlansLoading));

  @override
  SubscriptionPlansLoading get _value =>
      super._value as SubscriptionPlansLoading;
}

/// @nodoc

class _$SubscriptionPlansLoading
    with DiagnosticableTreeMixin
    implements SubscriptionPlansLoading {
  const _$SubscriptionPlansLoading();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SubscriptionPlansState.subscriptionPlansLoading()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'SubscriptionPlansState.subscriptionPlansLoading'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SubscriptionPlansLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() subscriptionPlansInitial,
    required TResult Function() subscriptionPlansLoading,
    required TResult Function(List<SubscriptionPlan> subscriptionPlans)
        subscriptionPlansLoaded,
    required TResult Function() subscriptionPlansEmpty,
  }) {
    return subscriptionPlansLoading();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? subscriptionPlansInitial,
    TResult Function()? subscriptionPlansLoading,
    TResult Function(List<SubscriptionPlan> subscriptionPlans)?
        subscriptionPlansLoaded,
    TResult Function()? subscriptionPlansEmpty,
    required TResult orElse(),
  }) {
    if (subscriptionPlansLoading != null) {
      return subscriptionPlansLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubscriptionPlansInitial value)
        subscriptionPlansInitial,
    required TResult Function(SubscriptionPlansLoading value)
        subscriptionPlansLoading,
    required TResult Function(SubscriptionPlansLoaded value)
        subscriptionPlansLoaded,
    required TResult Function(SubscriptionPlansEmpty value)
        subscriptionPlansEmpty,
  }) {
    return subscriptionPlansLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubscriptionPlansInitial value)? subscriptionPlansInitial,
    TResult Function(SubscriptionPlansLoading value)? subscriptionPlansLoading,
    TResult Function(SubscriptionPlansLoaded value)? subscriptionPlansLoaded,
    TResult Function(SubscriptionPlansEmpty value)? subscriptionPlansEmpty,
    required TResult orElse(),
  }) {
    if (subscriptionPlansLoading != null) {
      return subscriptionPlansLoading(this);
    }
    return orElse();
  }
}

abstract class SubscriptionPlansLoading implements SubscriptionPlansState {
  const factory SubscriptionPlansLoading() = _$SubscriptionPlansLoading;
}

/// @nodoc
abstract class $SubscriptionPlansLoadedCopyWith<$Res> {
  factory $SubscriptionPlansLoadedCopyWith(SubscriptionPlansLoaded value,
          $Res Function(SubscriptionPlansLoaded) then) =
      _$SubscriptionPlansLoadedCopyWithImpl<$Res>;
  $Res call({List<SubscriptionPlan> subscriptionPlans});
}

/// @nodoc
class _$SubscriptionPlansLoadedCopyWithImpl<$Res>
    extends _$SubscriptionPlansStateCopyWithImpl<$Res>
    implements $SubscriptionPlansLoadedCopyWith<$Res> {
  _$SubscriptionPlansLoadedCopyWithImpl(SubscriptionPlansLoaded _value,
      $Res Function(SubscriptionPlansLoaded) _then)
      : super(_value, (v) => _then(v as SubscriptionPlansLoaded));

  @override
  SubscriptionPlansLoaded get _value => super._value as SubscriptionPlansLoaded;

  @override
  $Res call({
    Object? subscriptionPlans = freezed,
  }) {
    return _then(SubscriptionPlansLoaded(
      subscriptionPlans: subscriptionPlans == freezed
          ? _value.subscriptionPlans
          : subscriptionPlans // ignore: cast_nullable_to_non_nullable
              as List<SubscriptionPlan>,
    ));
  }
}

/// @nodoc

class _$SubscriptionPlansLoaded
    with DiagnosticableTreeMixin
    implements SubscriptionPlansLoaded {
  const _$SubscriptionPlansLoaded({required this.subscriptionPlans});

  @override
  final List<SubscriptionPlan> subscriptionPlans;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SubscriptionPlansState.subscriptionPlansLoaded(subscriptionPlans: $subscriptionPlans)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'SubscriptionPlansState.subscriptionPlansLoaded'))
      ..add(DiagnosticsProperty('subscriptionPlans', subscriptionPlans));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SubscriptionPlansLoaded &&
            (identical(other.subscriptionPlans, subscriptionPlans) ||
                const DeepCollectionEquality()
                    .equals(other.subscriptionPlans, subscriptionPlans)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(subscriptionPlans);

  @JsonKey(ignore: true)
  @override
  $SubscriptionPlansLoadedCopyWith<SubscriptionPlansLoaded> get copyWith =>
      _$SubscriptionPlansLoadedCopyWithImpl<SubscriptionPlansLoaded>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() subscriptionPlansInitial,
    required TResult Function() subscriptionPlansLoading,
    required TResult Function(List<SubscriptionPlan> subscriptionPlans)
        subscriptionPlansLoaded,
    required TResult Function() subscriptionPlansEmpty,
  }) {
    return subscriptionPlansLoaded(subscriptionPlans);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? subscriptionPlansInitial,
    TResult Function()? subscriptionPlansLoading,
    TResult Function(List<SubscriptionPlan> subscriptionPlans)?
        subscriptionPlansLoaded,
    TResult Function()? subscriptionPlansEmpty,
    required TResult orElse(),
  }) {
    if (subscriptionPlansLoaded != null) {
      return subscriptionPlansLoaded(subscriptionPlans);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubscriptionPlansInitial value)
        subscriptionPlansInitial,
    required TResult Function(SubscriptionPlansLoading value)
        subscriptionPlansLoading,
    required TResult Function(SubscriptionPlansLoaded value)
        subscriptionPlansLoaded,
    required TResult Function(SubscriptionPlansEmpty value)
        subscriptionPlansEmpty,
  }) {
    return subscriptionPlansLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubscriptionPlansInitial value)? subscriptionPlansInitial,
    TResult Function(SubscriptionPlansLoading value)? subscriptionPlansLoading,
    TResult Function(SubscriptionPlansLoaded value)? subscriptionPlansLoaded,
    TResult Function(SubscriptionPlansEmpty value)? subscriptionPlansEmpty,
    required TResult orElse(),
  }) {
    if (subscriptionPlansLoaded != null) {
      return subscriptionPlansLoaded(this);
    }
    return orElse();
  }
}

abstract class SubscriptionPlansLoaded implements SubscriptionPlansState {
  const factory SubscriptionPlansLoaded(
          {required List<SubscriptionPlan> subscriptionPlans}) =
      _$SubscriptionPlansLoaded;

  List<SubscriptionPlan> get subscriptionPlans =>
      throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubscriptionPlansLoadedCopyWith<SubscriptionPlansLoaded> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubscriptionPlansEmptyCopyWith<$Res> {
  factory $SubscriptionPlansEmptyCopyWith(SubscriptionPlansEmpty value,
          $Res Function(SubscriptionPlansEmpty) then) =
      _$SubscriptionPlansEmptyCopyWithImpl<$Res>;
}

/// @nodoc
class _$SubscriptionPlansEmptyCopyWithImpl<$Res>
    extends _$SubscriptionPlansStateCopyWithImpl<$Res>
    implements $SubscriptionPlansEmptyCopyWith<$Res> {
  _$SubscriptionPlansEmptyCopyWithImpl(SubscriptionPlansEmpty _value,
      $Res Function(SubscriptionPlansEmpty) _then)
      : super(_value, (v) => _then(v as SubscriptionPlansEmpty));

  @override
  SubscriptionPlansEmpty get _value => super._value as SubscriptionPlansEmpty;
}

/// @nodoc

class _$SubscriptionPlansEmpty
    with DiagnosticableTreeMixin
    implements SubscriptionPlansEmpty {
  const _$SubscriptionPlansEmpty();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SubscriptionPlansState.subscriptionPlansEmpty()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'SubscriptionPlansState.subscriptionPlansEmpty'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SubscriptionPlansEmpty);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() subscriptionPlansInitial,
    required TResult Function() subscriptionPlansLoading,
    required TResult Function(List<SubscriptionPlan> subscriptionPlans)
        subscriptionPlansLoaded,
    required TResult Function() subscriptionPlansEmpty,
  }) {
    return subscriptionPlansEmpty();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? subscriptionPlansInitial,
    TResult Function()? subscriptionPlansLoading,
    TResult Function(List<SubscriptionPlan> subscriptionPlans)?
        subscriptionPlansLoaded,
    TResult Function()? subscriptionPlansEmpty,
    required TResult orElse(),
  }) {
    if (subscriptionPlansEmpty != null) {
      return subscriptionPlansEmpty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SubscriptionPlansInitial value)
        subscriptionPlansInitial,
    required TResult Function(SubscriptionPlansLoading value)
        subscriptionPlansLoading,
    required TResult Function(SubscriptionPlansLoaded value)
        subscriptionPlansLoaded,
    required TResult Function(SubscriptionPlansEmpty value)
        subscriptionPlansEmpty,
  }) {
    return subscriptionPlansEmpty(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SubscriptionPlansInitial value)? subscriptionPlansInitial,
    TResult Function(SubscriptionPlansLoading value)? subscriptionPlansLoading,
    TResult Function(SubscriptionPlansLoaded value)? subscriptionPlansLoaded,
    TResult Function(SubscriptionPlansEmpty value)? subscriptionPlansEmpty,
    required TResult orElse(),
  }) {
    if (subscriptionPlansEmpty != null) {
      return subscriptionPlansEmpty(this);
    }
    return orElse();
  }
}

abstract class SubscriptionPlansEmpty implements SubscriptionPlansState {
  const factory SubscriptionPlansEmpty() = _$SubscriptionPlansEmpty;
}
