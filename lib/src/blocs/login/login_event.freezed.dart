// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'login_event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$LoginEventTearOff {
  const _$LoginEventTearOff();

  LoginWithGoogle loginWithGoogle() {
    return const LoginWithGoogle();
  }

  LoginWithApple loginWithApple() {
    return const LoginWithApple();
  }

  LoginPasswordless loginPasswordless({required String userEmail}) {
    return LoginPasswordless(
      userEmail: userEmail,
    );
  }

  LoginWithTestUser loginWithTestUser() {
    return const LoginWithTestUser();
  }

  LoginWithTestUserTwo loginWithTestUserTwo() {
    return const LoginWithTestUserTwo();
  }

  LoginWithTestUserAdmin loginWithTestUserAdmin() {
    return const LoginWithTestUserAdmin();
  }

  LoginWithTestUserMaster loginWithTestUserMaster() {
    return const LoginWithTestUserMaster();
  }
}

/// @nodoc
const $LoginEvent = _$LoginEventTearOff();

/// @nodoc
mixin _$LoginEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loginWithGoogle,
    required TResult Function() loginWithApple,
    required TResult Function(String userEmail) loginPasswordless,
    required TResult Function() loginWithTestUser,
    required TResult Function() loginWithTestUserTwo,
    required TResult Function() loginWithTestUserAdmin,
    required TResult Function() loginWithTestUserMaster,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loginWithGoogle,
    TResult Function()? loginWithApple,
    TResult Function(String userEmail)? loginPasswordless,
    TResult Function()? loginWithTestUser,
    TResult Function()? loginWithTestUserTwo,
    TResult Function()? loginWithTestUserAdmin,
    TResult Function()? loginWithTestUserMaster,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoginWithGoogle value) loginWithGoogle,
    required TResult Function(LoginWithApple value) loginWithApple,
    required TResult Function(LoginPasswordless value) loginPasswordless,
    required TResult Function(LoginWithTestUser value) loginWithTestUser,
    required TResult Function(LoginWithTestUserTwo value) loginWithTestUserTwo,
    required TResult Function(LoginWithTestUserAdmin value)
        loginWithTestUserAdmin,
    required TResult Function(LoginWithTestUserMaster value)
        loginWithTestUserMaster,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoginWithGoogle value)? loginWithGoogle,
    TResult Function(LoginWithApple value)? loginWithApple,
    TResult Function(LoginPasswordless value)? loginPasswordless,
    TResult Function(LoginWithTestUser value)? loginWithTestUser,
    TResult Function(LoginWithTestUserTwo value)? loginWithTestUserTwo,
    TResult Function(LoginWithTestUserAdmin value)? loginWithTestUserAdmin,
    TResult Function(LoginWithTestUserMaster value)? loginWithTestUserMaster,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoginEventCopyWith<$Res> {
  factory $LoginEventCopyWith(
          LoginEvent value, $Res Function(LoginEvent) then) =
      _$LoginEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoginEventCopyWithImpl<$Res> implements $LoginEventCopyWith<$Res> {
  _$LoginEventCopyWithImpl(this._value, this._then);

  final LoginEvent _value;
  // ignore: unused_field
  final $Res Function(LoginEvent) _then;
}

/// @nodoc
abstract class $LoginWithGoogleCopyWith<$Res> {
  factory $LoginWithGoogleCopyWith(
          LoginWithGoogle value, $Res Function(LoginWithGoogle) then) =
      _$LoginWithGoogleCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoginWithGoogleCopyWithImpl<$Res> extends _$LoginEventCopyWithImpl<$Res>
    implements $LoginWithGoogleCopyWith<$Res> {
  _$LoginWithGoogleCopyWithImpl(
      LoginWithGoogle _value, $Res Function(LoginWithGoogle) _then)
      : super(_value, (v) => _then(v as LoginWithGoogle));

  @override
  LoginWithGoogle get _value => super._value as LoginWithGoogle;
}

/// @nodoc

class _$LoginWithGoogle
    with DiagnosticableTreeMixin
    implements LoginWithGoogle {
  const _$LoginWithGoogle();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LoginEvent.loginWithGoogle()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'LoginEvent.loginWithGoogle'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is LoginWithGoogle);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loginWithGoogle,
    required TResult Function() loginWithApple,
    required TResult Function(String userEmail) loginPasswordless,
    required TResult Function() loginWithTestUser,
    required TResult Function() loginWithTestUserTwo,
    required TResult Function() loginWithTestUserAdmin,
    required TResult Function() loginWithTestUserMaster,
  }) {
    return loginWithGoogle();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loginWithGoogle,
    TResult Function()? loginWithApple,
    TResult Function(String userEmail)? loginPasswordless,
    TResult Function()? loginWithTestUser,
    TResult Function()? loginWithTestUserTwo,
    TResult Function()? loginWithTestUserAdmin,
    TResult Function()? loginWithTestUserMaster,
    required TResult orElse(),
  }) {
    if (loginWithGoogle != null) {
      return loginWithGoogle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoginWithGoogle value) loginWithGoogle,
    required TResult Function(LoginWithApple value) loginWithApple,
    required TResult Function(LoginPasswordless value) loginPasswordless,
    required TResult Function(LoginWithTestUser value) loginWithTestUser,
    required TResult Function(LoginWithTestUserTwo value) loginWithTestUserTwo,
    required TResult Function(LoginWithTestUserAdmin value)
        loginWithTestUserAdmin,
    required TResult Function(LoginWithTestUserMaster value)
        loginWithTestUserMaster,
  }) {
    return loginWithGoogle(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoginWithGoogle value)? loginWithGoogle,
    TResult Function(LoginWithApple value)? loginWithApple,
    TResult Function(LoginPasswordless value)? loginPasswordless,
    TResult Function(LoginWithTestUser value)? loginWithTestUser,
    TResult Function(LoginWithTestUserTwo value)? loginWithTestUserTwo,
    TResult Function(LoginWithTestUserAdmin value)? loginWithTestUserAdmin,
    TResult Function(LoginWithTestUserMaster value)? loginWithTestUserMaster,
    required TResult orElse(),
  }) {
    if (loginWithGoogle != null) {
      return loginWithGoogle(this);
    }
    return orElse();
  }
}

abstract class LoginWithGoogle implements LoginEvent {
  const factory LoginWithGoogle() = _$LoginWithGoogle;
}

/// @nodoc
abstract class $LoginWithAppleCopyWith<$Res> {
  factory $LoginWithAppleCopyWith(
          LoginWithApple value, $Res Function(LoginWithApple) then) =
      _$LoginWithAppleCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoginWithAppleCopyWithImpl<$Res> extends _$LoginEventCopyWithImpl<$Res>
    implements $LoginWithAppleCopyWith<$Res> {
  _$LoginWithAppleCopyWithImpl(
      LoginWithApple _value, $Res Function(LoginWithApple) _then)
      : super(_value, (v) => _then(v as LoginWithApple));

  @override
  LoginWithApple get _value => super._value as LoginWithApple;
}

/// @nodoc

class _$LoginWithApple with DiagnosticableTreeMixin implements LoginWithApple {
  const _$LoginWithApple();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LoginEvent.loginWithApple()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'LoginEvent.loginWithApple'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is LoginWithApple);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loginWithGoogle,
    required TResult Function() loginWithApple,
    required TResult Function(String userEmail) loginPasswordless,
    required TResult Function() loginWithTestUser,
    required TResult Function() loginWithTestUserTwo,
    required TResult Function() loginWithTestUserAdmin,
    required TResult Function() loginWithTestUserMaster,
  }) {
    return loginWithApple();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loginWithGoogle,
    TResult Function()? loginWithApple,
    TResult Function(String userEmail)? loginPasswordless,
    TResult Function()? loginWithTestUser,
    TResult Function()? loginWithTestUserTwo,
    TResult Function()? loginWithTestUserAdmin,
    TResult Function()? loginWithTestUserMaster,
    required TResult orElse(),
  }) {
    if (loginWithApple != null) {
      return loginWithApple();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoginWithGoogle value) loginWithGoogle,
    required TResult Function(LoginWithApple value) loginWithApple,
    required TResult Function(LoginPasswordless value) loginPasswordless,
    required TResult Function(LoginWithTestUser value) loginWithTestUser,
    required TResult Function(LoginWithTestUserTwo value) loginWithTestUserTwo,
    required TResult Function(LoginWithTestUserAdmin value)
        loginWithTestUserAdmin,
    required TResult Function(LoginWithTestUserMaster value)
        loginWithTestUserMaster,
  }) {
    return loginWithApple(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoginWithGoogle value)? loginWithGoogle,
    TResult Function(LoginWithApple value)? loginWithApple,
    TResult Function(LoginPasswordless value)? loginPasswordless,
    TResult Function(LoginWithTestUser value)? loginWithTestUser,
    TResult Function(LoginWithTestUserTwo value)? loginWithTestUserTwo,
    TResult Function(LoginWithTestUserAdmin value)? loginWithTestUserAdmin,
    TResult Function(LoginWithTestUserMaster value)? loginWithTestUserMaster,
    required TResult orElse(),
  }) {
    if (loginWithApple != null) {
      return loginWithApple(this);
    }
    return orElse();
  }
}

abstract class LoginWithApple implements LoginEvent {
  const factory LoginWithApple() = _$LoginWithApple;
}

/// @nodoc
abstract class $LoginPasswordlessCopyWith<$Res> {
  factory $LoginPasswordlessCopyWith(
          LoginPasswordless value, $Res Function(LoginPasswordless) then) =
      _$LoginPasswordlessCopyWithImpl<$Res>;
  $Res call({String userEmail});
}

/// @nodoc
class _$LoginPasswordlessCopyWithImpl<$Res>
    extends _$LoginEventCopyWithImpl<$Res>
    implements $LoginPasswordlessCopyWith<$Res> {
  _$LoginPasswordlessCopyWithImpl(
      LoginPasswordless _value, $Res Function(LoginPasswordless) _then)
      : super(_value, (v) => _then(v as LoginPasswordless));

  @override
  LoginPasswordless get _value => super._value as LoginPasswordless;

  @override
  $Res call({
    Object? userEmail = freezed,
  }) {
    return _then(LoginPasswordless(
      userEmail: userEmail == freezed
          ? _value.userEmail
          : userEmail // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$LoginPasswordless
    with DiagnosticableTreeMixin
    implements LoginPasswordless {
  const _$LoginPasswordless({required this.userEmail});

  @override
  final String userEmail;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LoginEvent.loginPasswordless(userEmail: $userEmail)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LoginEvent.loginPasswordless'))
      ..add(DiagnosticsProperty('userEmail', userEmail));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LoginPasswordless &&
            (identical(other.userEmail, userEmail) ||
                const DeepCollectionEquality()
                    .equals(other.userEmail, userEmail)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(userEmail);

  @JsonKey(ignore: true)
  @override
  $LoginPasswordlessCopyWith<LoginPasswordless> get copyWith =>
      _$LoginPasswordlessCopyWithImpl<LoginPasswordless>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loginWithGoogle,
    required TResult Function() loginWithApple,
    required TResult Function(String userEmail) loginPasswordless,
    required TResult Function() loginWithTestUser,
    required TResult Function() loginWithTestUserTwo,
    required TResult Function() loginWithTestUserAdmin,
    required TResult Function() loginWithTestUserMaster,
  }) {
    return loginPasswordless(userEmail);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loginWithGoogle,
    TResult Function()? loginWithApple,
    TResult Function(String userEmail)? loginPasswordless,
    TResult Function()? loginWithTestUser,
    TResult Function()? loginWithTestUserTwo,
    TResult Function()? loginWithTestUserAdmin,
    TResult Function()? loginWithTestUserMaster,
    required TResult orElse(),
  }) {
    if (loginPasswordless != null) {
      return loginPasswordless(userEmail);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoginWithGoogle value) loginWithGoogle,
    required TResult Function(LoginWithApple value) loginWithApple,
    required TResult Function(LoginPasswordless value) loginPasswordless,
    required TResult Function(LoginWithTestUser value) loginWithTestUser,
    required TResult Function(LoginWithTestUserTwo value) loginWithTestUserTwo,
    required TResult Function(LoginWithTestUserAdmin value)
        loginWithTestUserAdmin,
    required TResult Function(LoginWithTestUserMaster value)
        loginWithTestUserMaster,
  }) {
    return loginPasswordless(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoginWithGoogle value)? loginWithGoogle,
    TResult Function(LoginWithApple value)? loginWithApple,
    TResult Function(LoginPasswordless value)? loginPasswordless,
    TResult Function(LoginWithTestUser value)? loginWithTestUser,
    TResult Function(LoginWithTestUserTwo value)? loginWithTestUserTwo,
    TResult Function(LoginWithTestUserAdmin value)? loginWithTestUserAdmin,
    TResult Function(LoginWithTestUserMaster value)? loginWithTestUserMaster,
    required TResult orElse(),
  }) {
    if (loginPasswordless != null) {
      return loginPasswordless(this);
    }
    return orElse();
  }
}

abstract class LoginPasswordless implements LoginEvent {
  const factory LoginPasswordless({required String userEmail}) =
      _$LoginPasswordless;

  String get userEmail => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LoginPasswordlessCopyWith<LoginPasswordless> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoginWithTestUserCopyWith<$Res> {
  factory $LoginWithTestUserCopyWith(
          LoginWithTestUser value, $Res Function(LoginWithTestUser) then) =
      _$LoginWithTestUserCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoginWithTestUserCopyWithImpl<$Res>
    extends _$LoginEventCopyWithImpl<$Res>
    implements $LoginWithTestUserCopyWith<$Res> {
  _$LoginWithTestUserCopyWithImpl(
      LoginWithTestUser _value, $Res Function(LoginWithTestUser) _then)
      : super(_value, (v) => _then(v as LoginWithTestUser));

  @override
  LoginWithTestUser get _value => super._value as LoginWithTestUser;
}

/// @nodoc

class _$LoginWithTestUser
    with DiagnosticableTreeMixin
    implements LoginWithTestUser {
  const _$LoginWithTestUser();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LoginEvent.loginWithTestUser()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LoginEvent.loginWithTestUser'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is LoginWithTestUser);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loginWithGoogle,
    required TResult Function() loginWithApple,
    required TResult Function(String userEmail) loginPasswordless,
    required TResult Function() loginWithTestUser,
    required TResult Function() loginWithTestUserTwo,
    required TResult Function() loginWithTestUserAdmin,
    required TResult Function() loginWithTestUserMaster,
  }) {
    return loginWithTestUser();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loginWithGoogle,
    TResult Function()? loginWithApple,
    TResult Function(String userEmail)? loginPasswordless,
    TResult Function()? loginWithTestUser,
    TResult Function()? loginWithTestUserTwo,
    TResult Function()? loginWithTestUserAdmin,
    TResult Function()? loginWithTestUserMaster,
    required TResult orElse(),
  }) {
    if (loginWithTestUser != null) {
      return loginWithTestUser();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoginWithGoogle value) loginWithGoogle,
    required TResult Function(LoginWithApple value) loginWithApple,
    required TResult Function(LoginPasswordless value) loginPasswordless,
    required TResult Function(LoginWithTestUser value) loginWithTestUser,
    required TResult Function(LoginWithTestUserTwo value) loginWithTestUserTwo,
    required TResult Function(LoginWithTestUserAdmin value)
        loginWithTestUserAdmin,
    required TResult Function(LoginWithTestUserMaster value)
        loginWithTestUserMaster,
  }) {
    return loginWithTestUser(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoginWithGoogle value)? loginWithGoogle,
    TResult Function(LoginWithApple value)? loginWithApple,
    TResult Function(LoginPasswordless value)? loginPasswordless,
    TResult Function(LoginWithTestUser value)? loginWithTestUser,
    TResult Function(LoginWithTestUserTwo value)? loginWithTestUserTwo,
    TResult Function(LoginWithTestUserAdmin value)? loginWithTestUserAdmin,
    TResult Function(LoginWithTestUserMaster value)? loginWithTestUserMaster,
    required TResult orElse(),
  }) {
    if (loginWithTestUser != null) {
      return loginWithTestUser(this);
    }
    return orElse();
  }
}

abstract class LoginWithTestUser implements LoginEvent {
  const factory LoginWithTestUser() = _$LoginWithTestUser;
}

/// @nodoc
abstract class $LoginWithTestUserTwoCopyWith<$Res> {
  factory $LoginWithTestUserTwoCopyWith(LoginWithTestUserTwo value,
          $Res Function(LoginWithTestUserTwo) then) =
      _$LoginWithTestUserTwoCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoginWithTestUserTwoCopyWithImpl<$Res>
    extends _$LoginEventCopyWithImpl<$Res>
    implements $LoginWithTestUserTwoCopyWith<$Res> {
  _$LoginWithTestUserTwoCopyWithImpl(
      LoginWithTestUserTwo _value, $Res Function(LoginWithTestUserTwo) _then)
      : super(_value, (v) => _then(v as LoginWithTestUserTwo));

  @override
  LoginWithTestUserTwo get _value => super._value as LoginWithTestUserTwo;
}

/// @nodoc

class _$LoginWithTestUserTwo
    with DiagnosticableTreeMixin
    implements LoginWithTestUserTwo {
  const _$LoginWithTestUserTwo();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LoginEvent.loginWithTestUserTwo()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LoginEvent.loginWithTestUserTwo'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is LoginWithTestUserTwo);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loginWithGoogle,
    required TResult Function() loginWithApple,
    required TResult Function(String userEmail) loginPasswordless,
    required TResult Function() loginWithTestUser,
    required TResult Function() loginWithTestUserTwo,
    required TResult Function() loginWithTestUserAdmin,
    required TResult Function() loginWithTestUserMaster,
  }) {
    return loginWithTestUserTwo();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loginWithGoogle,
    TResult Function()? loginWithApple,
    TResult Function(String userEmail)? loginPasswordless,
    TResult Function()? loginWithTestUser,
    TResult Function()? loginWithTestUserTwo,
    TResult Function()? loginWithTestUserAdmin,
    TResult Function()? loginWithTestUserMaster,
    required TResult orElse(),
  }) {
    if (loginWithTestUserTwo != null) {
      return loginWithTestUserTwo();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoginWithGoogle value) loginWithGoogle,
    required TResult Function(LoginWithApple value) loginWithApple,
    required TResult Function(LoginPasswordless value) loginPasswordless,
    required TResult Function(LoginWithTestUser value) loginWithTestUser,
    required TResult Function(LoginWithTestUserTwo value) loginWithTestUserTwo,
    required TResult Function(LoginWithTestUserAdmin value)
        loginWithTestUserAdmin,
    required TResult Function(LoginWithTestUserMaster value)
        loginWithTestUserMaster,
  }) {
    return loginWithTestUserTwo(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoginWithGoogle value)? loginWithGoogle,
    TResult Function(LoginWithApple value)? loginWithApple,
    TResult Function(LoginPasswordless value)? loginPasswordless,
    TResult Function(LoginWithTestUser value)? loginWithTestUser,
    TResult Function(LoginWithTestUserTwo value)? loginWithTestUserTwo,
    TResult Function(LoginWithTestUserAdmin value)? loginWithTestUserAdmin,
    TResult Function(LoginWithTestUserMaster value)? loginWithTestUserMaster,
    required TResult orElse(),
  }) {
    if (loginWithTestUserTwo != null) {
      return loginWithTestUserTwo(this);
    }
    return orElse();
  }
}

abstract class LoginWithTestUserTwo implements LoginEvent {
  const factory LoginWithTestUserTwo() = _$LoginWithTestUserTwo;
}

/// @nodoc
abstract class $LoginWithTestUserAdminCopyWith<$Res> {
  factory $LoginWithTestUserAdminCopyWith(LoginWithTestUserAdmin value,
          $Res Function(LoginWithTestUserAdmin) then) =
      _$LoginWithTestUserAdminCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoginWithTestUserAdminCopyWithImpl<$Res>
    extends _$LoginEventCopyWithImpl<$Res>
    implements $LoginWithTestUserAdminCopyWith<$Res> {
  _$LoginWithTestUserAdminCopyWithImpl(LoginWithTestUserAdmin _value,
      $Res Function(LoginWithTestUserAdmin) _then)
      : super(_value, (v) => _then(v as LoginWithTestUserAdmin));

  @override
  LoginWithTestUserAdmin get _value => super._value as LoginWithTestUserAdmin;
}

/// @nodoc

class _$LoginWithTestUserAdmin
    with DiagnosticableTreeMixin
    implements LoginWithTestUserAdmin {
  const _$LoginWithTestUserAdmin();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LoginEvent.loginWithTestUserAdmin()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LoginEvent.loginWithTestUserAdmin'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is LoginWithTestUserAdmin);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loginWithGoogle,
    required TResult Function() loginWithApple,
    required TResult Function(String userEmail) loginPasswordless,
    required TResult Function() loginWithTestUser,
    required TResult Function() loginWithTestUserTwo,
    required TResult Function() loginWithTestUserAdmin,
    required TResult Function() loginWithTestUserMaster,
  }) {
    return loginWithTestUserAdmin();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loginWithGoogle,
    TResult Function()? loginWithApple,
    TResult Function(String userEmail)? loginPasswordless,
    TResult Function()? loginWithTestUser,
    TResult Function()? loginWithTestUserTwo,
    TResult Function()? loginWithTestUserAdmin,
    TResult Function()? loginWithTestUserMaster,
    required TResult orElse(),
  }) {
    if (loginWithTestUserAdmin != null) {
      return loginWithTestUserAdmin();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoginWithGoogle value) loginWithGoogle,
    required TResult Function(LoginWithApple value) loginWithApple,
    required TResult Function(LoginPasswordless value) loginPasswordless,
    required TResult Function(LoginWithTestUser value) loginWithTestUser,
    required TResult Function(LoginWithTestUserTwo value) loginWithTestUserTwo,
    required TResult Function(LoginWithTestUserAdmin value)
        loginWithTestUserAdmin,
    required TResult Function(LoginWithTestUserMaster value)
        loginWithTestUserMaster,
  }) {
    return loginWithTestUserAdmin(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoginWithGoogle value)? loginWithGoogle,
    TResult Function(LoginWithApple value)? loginWithApple,
    TResult Function(LoginPasswordless value)? loginPasswordless,
    TResult Function(LoginWithTestUser value)? loginWithTestUser,
    TResult Function(LoginWithTestUserTwo value)? loginWithTestUserTwo,
    TResult Function(LoginWithTestUserAdmin value)? loginWithTestUserAdmin,
    TResult Function(LoginWithTestUserMaster value)? loginWithTestUserMaster,
    required TResult orElse(),
  }) {
    if (loginWithTestUserAdmin != null) {
      return loginWithTestUserAdmin(this);
    }
    return orElse();
  }
}

abstract class LoginWithTestUserAdmin implements LoginEvent {
  const factory LoginWithTestUserAdmin() = _$LoginWithTestUserAdmin;
}

/// @nodoc
abstract class $LoginWithTestUserMasterCopyWith<$Res> {
  factory $LoginWithTestUserMasterCopyWith(LoginWithTestUserMaster value,
          $Res Function(LoginWithTestUserMaster) then) =
      _$LoginWithTestUserMasterCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoginWithTestUserMasterCopyWithImpl<$Res>
    extends _$LoginEventCopyWithImpl<$Res>
    implements $LoginWithTestUserMasterCopyWith<$Res> {
  _$LoginWithTestUserMasterCopyWithImpl(LoginWithTestUserMaster _value,
      $Res Function(LoginWithTestUserMaster) _then)
      : super(_value, (v) => _then(v as LoginWithTestUserMaster));

  @override
  LoginWithTestUserMaster get _value => super._value as LoginWithTestUserMaster;
}

/// @nodoc

class _$LoginWithTestUserMaster
    with DiagnosticableTreeMixin
    implements LoginWithTestUserMaster {
  const _$LoginWithTestUserMaster();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LoginEvent.loginWithTestUserMaster()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LoginEvent.loginWithTestUserMaster'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is LoginWithTestUserMaster);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loginWithGoogle,
    required TResult Function() loginWithApple,
    required TResult Function(String userEmail) loginPasswordless,
    required TResult Function() loginWithTestUser,
    required TResult Function() loginWithTestUserTwo,
    required TResult Function() loginWithTestUserAdmin,
    required TResult Function() loginWithTestUserMaster,
  }) {
    return loginWithTestUserMaster();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loginWithGoogle,
    TResult Function()? loginWithApple,
    TResult Function(String userEmail)? loginPasswordless,
    TResult Function()? loginWithTestUser,
    TResult Function()? loginWithTestUserTwo,
    TResult Function()? loginWithTestUserAdmin,
    TResult Function()? loginWithTestUserMaster,
    required TResult orElse(),
  }) {
    if (loginWithTestUserMaster != null) {
      return loginWithTestUserMaster();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoginWithGoogle value) loginWithGoogle,
    required TResult Function(LoginWithApple value) loginWithApple,
    required TResult Function(LoginPasswordless value) loginPasswordless,
    required TResult Function(LoginWithTestUser value) loginWithTestUser,
    required TResult Function(LoginWithTestUserTwo value) loginWithTestUserTwo,
    required TResult Function(LoginWithTestUserAdmin value)
        loginWithTestUserAdmin,
    required TResult Function(LoginWithTestUserMaster value)
        loginWithTestUserMaster,
  }) {
    return loginWithTestUserMaster(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoginWithGoogle value)? loginWithGoogle,
    TResult Function(LoginWithApple value)? loginWithApple,
    TResult Function(LoginPasswordless value)? loginPasswordless,
    TResult Function(LoginWithTestUser value)? loginWithTestUser,
    TResult Function(LoginWithTestUserTwo value)? loginWithTestUserTwo,
    TResult Function(LoginWithTestUserAdmin value)? loginWithTestUserAdmin,
    TResult Function(LoginWithTestUserMaster value)? loginWithTestUserMaster,
    required TResult orElse(),
  }) {
    if (loginWithTestUserMaster != null) {
      return loginWithTestUserMaster(this);
    }
    return orElse();
  }
}

abstract class LoginWithTestUserMaster implements LoginEvent {
  const factory LoginWithTestUserMaster() = _$LoginWithTestUserMaster;
}
