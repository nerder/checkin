// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'login_event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$LoginEventTearOff {
  const _$LoginEventTearOff();

// ignore: unused_element
  LoginWithGoogle loginWithGoogle() {
    return const LoginWithGoogle();
  }

// ignore: unused_element
  LoginWithApple loginWithApple() {
    return const LoginWithApple();
  }

// ignore: unused_element
  LoginPasswordless loginPasswordless({@required String userEmail}) {
    return LoginPasswordless(
      userEmail: userEmail,
    );
  }

// ignore: unused_element
  LoginWithTestUser loginWithTestUser() {
    return const LoginWithTestUser();
  }

// ignore: unused_element
  LoginWithTestUserTwo loginWithTestUserTwo() {
    return const LoginWithTestUserTwo();
  }

// ignore: unused_element
  LoginWithTestUserAdmin loginWithTestUserAdmin() {
    return const LoginWithTestUserAdmin();
  }

// ignore: unused_element
  LoginWithTestUserMaster loginWithTestUserMaster() {
    return const LoginWithTestUserMaster();
  }
}

/// @nodoc
// ignore: unused_element
const $LoginEvent = _$LoginEventTearOff();

/// @nodoc
mixin _$LoginEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult loginWithGoogle(),
    @required TResult loginWithApple(),
    @required TResult loginPasswordless(String userEmail),
    @required TResult loginWithTestUser(),
    @required TResult loginWithTestUserTwo(),
    @required TResult loginWithTestUserAdmin(),
    @required TResult loginWithTestUserMaster(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult loginWithGoogle(),
    TResult loginWithApple(),
    TResult loginPasswordless(String userEmail),
    TResult loginWithTestUser(),
    TResult loginWithTestUserTwo(),
    TResult loginWithTestUserAdmin(),
    TResult loginWithTestUserMaster(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult loginWithGoogle(LoginWithGoogle value),
    @required TResult loginWithApple(LoginWithApple value),
    @required TResult loginPasswordless(LoginPasswordless value),
    @required TResult loginWithTestUser(LoginWithTestUser value),
    @required TResult loginWithTestUserTwo(LoginWithTestUserTwo value),
    @required TResult loginWithTestUserAdmin(LoginWithTestUserAdmin value),
    @required TResult loginWithTestUserMaster(LoginWithTestUserMaster value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult loginWithGoogle(LoginWithGoogle value),
    TResult loginWithApple(LoginWithApple value),
    TResult loginPasswordless(LoginPasswordless value),
    TResult loginWithTestUser(LoginWithTestUser value),
    TResult loginWithTestUserTwo(LoginWithTestUserTwo value),
    TResult loginWithTestUserAdmin(LoginWithTestUserAdmin value),
    TResult loginWithTestUserMaster(LoginWithTestUserMaster value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $LoginEventCopyWith<$Res> {
  factory $LoginEventCopyWith(LoginEvent value, $Res Function(LoginEvent) then) =
      _$LoginEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoginEventCopyWithImpl<$Res> implements $LoginEventCopyWith<$Res> {
  _$LoginEventCopyWithImpl(this._value, this._then);

  final LoginEvent _value;
  // ignore: unused_field
  final $Res Function(LoginEvent) _then;
}

/// @nodoc
abstract class $LoginWithGoogleCopyWith<$Res> {
  factory $LoginWithGoogleCopyWith(LoginWithGoogle value, $Res Function(LoginWithGoogle) then) =
      _$LoginWithGoogleCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoginWithGoogleCopyWithImpl<$Res> extends _$LoginEventCopyWithImpl<$Res>
    implements $LoginWithGoogleCopyWith<$Res> {
  _$LoginWithGoogleCopyWithImpl(LoginWithGoogle _value, $Res Function(LoginWithGoogle) _then)
      : super(_value, (v) => _then(v as LoginWithGoogle));

  @override
  LoginWithGoogle get _value => super._value as LoginWithGoogle;
}

/// @nodoc
class _$LoginWithGoogle with DiagnosticableTreeMixin implements LoginWithGoogle {
  const _$LoginWithGoogle();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LoginEvent.loginWithGoogle()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'LoginEvent.loginWithGoogle'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is LoginWithGoogle);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult loginWithGoogle(),
    @required TResult loginWithApple(),
    @required TResult loginPasswordless(String userEmail),
    @required TResult loginWithTestUser(),
    @required TResult loginWithTestUserTwo(),
    @required TResult loginWithTestUserAdmin(),
    @required TResult loginWithTestUserMaster(),
  }) {
    assert(loginWithGoogle != null);
    assert(loginWithApple != null);
    assert(loginPasswordless != null);
    assert(loginWithTestUser != null);
    assert(loginWithTestUserTwo != null);
    assert(loginWithTestUserAdmin != null);
    assert(loginWithTestUserMaster != null);
    return loginWithGoogle();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult loginWithGoogle(),
    TResult loginWithApple(),
    TResult loginPasswordless(String userEmail),
    TResult loginWithTestUser(),
    TResult loginWithTestUserTwo(),
    TResult loginWithTestUserAdmin(),
    TResult loginWithTestUserMaster(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loginWithGoogle != null) {
      return loginWithGoogle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult loginWithGoogle(LoginWithGoogle value),
    @required TResult loginWithApple(LoginWithApple value),
    @required TResult loginPasswordless(LoginPasswordless value),
    @required TResult loginWithTestUser(LoginWithTestUser value),
    @required TResult loginWithTestUserTwo(LoginWithTestUserTwo value),
    @required TResult loginWithTestUserAdmin(LoginWithTestUserAdmin value),
    @required TResult loginWithTestUserMaster(LoginWithTestUserMaster value),
  }) {
    assert(loginWithGoogle != null);
    assert(loginWithApple != null);
    assert(loginPasswordless != null);
    assert(loginWithTestUser != null);
    assert(loginWithTestUserTwo != null);
    assert(loginWithTestUserAdmin != null);
    assert(loginWithTestUserMaster != null);
    return loginWithGoogle(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult loginWithGoogle(LoginWithGoogle value),
    TResult loginWithApple(LoginWithApple value),
    TResult loginPasswordless(LoginPasswordless value),
    TResult loginWithTestUser(LoginWithTestUser value),
    TResult loginWithTestUserTwo(LoginWithTestUserTwo value),
    TResult loginWithTestUserAdmin(LoginWithTestUserAdmin value),
    TResult loginWithTestUserMaster(LoginWithTestUserMaster value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loginWithGoogle != null) {
      return loginWithGoogle(this);
    }
    return orElse();
  }
}

abstract class LoginWithGoogle implements LoginEvent {
  const factory LoginWithGoogle() = _$LoginWithGoogle;
}

/// @nodoc
abstract class $LoginWithAppleCopyWith<$Res> {
  factory $LoginWithAppleCopyWith(LoginWithApple value, $Res Function(LoginWithApple) then) =
      _$LoginWithAppleCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoginWithAppleCopyWithImpl<$Res> extends _$LoginEventCopyWithImpl<$Res>
    implements $LoginWithAppleCopyWith<$Res> {
  _$LoginWithAppleCopyWithImpl(LoginWithApple _value, $Res Function(LoginWithApple) _then)
      : super(_value, (v) => _then(v as LoginWithApple));

  @override
  LoginWithApple get _value => super._value as LoginWithApple;
}

/// @nodoc
class _$LoginWithApple with DiagnosticableTreeMixin implements LoginWithApple {
  const _$LoginWithApple();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LoginEvent.loginWithApple()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'LoginEvent.loginWithApple'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is LoginWithApple);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult loginWithGoogle(),
    @required TResult loginWithApple(),
    @required TResult loginPasswordless(String userEmail),
    @required TResult loginWithTestUser(),
    @required TResult loginWithTestUserTwo(),
    @required TResult loginWithTestUserAdmin(),
    @required TResult loginWithTestUserMaster(),
  }) {
    assert(loginWithGoogle != null);
    assert(loginWithApple != null);
    assert(loginPasswordless != null);
    assert(loginWithTestUser != null);
    assert(loginWithTestUserTwo != null);
    assert(loginWithTestUserAdmin != null);
    assert(loginWithTestUserMaster != null);
    return loginWithApple();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult loginWithGoogle(),
    TResult loginWithApple(),
    TResult loginPasswordless(String userEmail),
    TResult loginWithTestUser(),
    TResult loginWithTestUserTwo(),
    TResult loginWithTestUserAdmin(),
    TResult loginWithTestUserMaster(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loginWithApple != null) {
      return loginWithApple();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult loginWithGoogle(LoginWithGoogle value),
    @required TResult loginWithApple(LoginWithApple value),
    @required TResult loginPasswordless(LoginPasswordless value),
    @required TResult loginWithTestUser(LoginWithTestUser value),
    @required TResult loginWithTestUserTwo(LoginWithTestUserTwo value),
    @required TResult loginWithTestUserAdmin(LoginWithTestUserAdmin value),
    @required TResult loginWithTestUserMaster(LoginWithTestUserMaster value),
  }) {
    assert(loginWithGoogle != null);
    assert(loginWithApple != null);
    assert(loginPasswordless != null);
    assert(loginWithTestUser != null);
    assert(loginWithTestUserTwo != null);
    assert(loginWithTestUserAdmin != null);
    assert(loginWithTestUserMaster != null);
    return loginWithApple(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult loginWithGoogle(LoginWithGoogle value),
    TResult loginWithApple(LoginWithApple value),
    TResult loginPasswordless(LoginPasswordless value),
    TResult loginWithTestUser(LoginWithTestUser value),
    TResult loginWithTestUserTwo(LoginWithTestUserTwo value),
    TResult loginWithTestUserAdmin(LoginWithTestUserAdmin value),
    TResult loginWithTestUserMaster(LoginWithTestUserMaster value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loginWithApple != null) {
      return loginWithApple(this);
    }
    return orElse();
  }
}

abstract class LoginWithApple implements LoginEvent {
  const factory LoginWithApple() = _$LoginWithApple;
}

/// @nodoc
abstract class $LoginPasswordlessCopyWith<$Res> {
  factory $LoginPasswordlessCopyWith(
          LoginPasswordless value, $Res Function(LoginPasswordless) then) =
      _$LoginPasswordlessCopyWithImpl<$Res>;
  $Res call({String userEmail});
}

/// @nodoc
class _$LoginPasswordlessCopyWithImpl<$Res> extends _$LoginEventCopyWithImpl<$Res>
    implements $LoginPasswordlessCopyWith<$Res> {
  _$LoginPasswordlessCopyWithImpl(LoginPasswordless _value, $Res Function(LoginPasswordless) _then)
      : super(_value, (v) => _then(v as LoginPasswordless));

  @override
  LoginPasswordless get _value => super._value as LoginPasswordless;

  @override
  $Res call({
    Object userEmail = freezed,
  }) {
    return _then(LoginPasswordless(
      userEmail: userEmail == freezed ? _value.userEmail : userEmail as String,
    ));
  }
}

/// @nodoc
class _$LoginPasswordless with DiagnosticableTreeMixin implements LoginPasswordless {
  const _$LoginPasswordless({@required this.userEmail}) : assert(userEmail != null);

  @override
  final String userEmail;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LoginEvent.loginPasswordless(userEmail: $userEmail)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LoginEvent.loginPasswordless'))
      ..add(DiagnosticsProperty('userEmail', userEmail));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LoginPasswordless &&
            (identical(other.userEmail, userEmail) ||
                const DeepCollectionEquality().equals(other.userEmail, userEmail)));
  }

  @override
  int get hashCode => runtimeType.hashCode ^ const DeepCollectionEquality().hash(userEmail);

  @override
  $LoginPasswordlessCopyWith<LoginPasswordless> get copyWith =>
      _$LoginPasswordlessCopyWithImpl<LoginPasswordless>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult loginWithGoogle(),
    @required TResult loginWithApple(),
    @required TResult loginPasswordless(String userEmail),
    @required TResult loginWithTestUser(),
    @required TResult loginWithTestUserTwo(),
    @required TResult loginWithTestUserAdmin(),
    @required TResult loginWithTestUserMaster(),
  }) {
    assert(loginWithGoogle != null);
    assert(loginWithApple != null);
    assert(loginPasswordless != null);
    assert(loginWithTestUser != null);
    assert(loginWithTestUserTwo != null);
    assert(loginWithTestUserAdmin != null);
    assert(loginWithTestUserMaster != null);
    return loginPasswordless(userEmail);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult loginWithGoogle(),
    TResult loginWithApple(),
    TResult loginPasswordless(String userEmail),
    TResult loginWithTestUser(),
    TResult loginWithTestUserTwo(),
    TResult loginWithTestUserAdmin(),
    TResult loginWithTestUserMaster(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loginPasswordless != null) {
      return loginPasswordless(userEmail);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult loginWithGoogle(LoginWithGoogle value),
    @required TResult loginWithApple(LoginWithApple value),
    @required TResult loginPasswordless(LoginPasswordless value),
    @required TResult loginWithTestUser(LoginWithTestUser value),
    @required TResult loginWithTestUserTwo(LoginWithTestUserTwo value),
    @required TResult loginWithTestUserAdmin(LoginWithTestUserAdmin value),
    @required TResult loginWithTestUserMaster(LoginWithTestUserMaster value),
  }) {
    assert(loginWithGoogle != null);
    assert(loginWithApple != null);
    assert(loginPasswordless != null);
    assert(loginWithTestUser != null);
    assert(loginWithTestUserTwo != null);
    assert(loginWithTestUserAdmin != null);
    assert(loginWithTestUserMaster != null);
    return loginPasswordless(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult loginWithGoogle(LoginWithGoogle value),
    TResult loginWithApple(LoginWithApple value),
    TResult loginPasswordless(LoginPasswordless value),
    TResult loginWithTestUser(LoginWithTestUser value),
    TResult loginWithTestUserTwo(LoginWithTestUserTwo value),
    TResult loginWithTestUserAdmin(LoginWithTestUserAdmin value),
    TResult loginWithTestUserMaster(LoginWithTestUserMaster value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loginPasswordless != null) {
      return loginPasswordless(this);
    }
    return orElse();
  }
}

abstract class LoginPasswordless implements LoginEvent {
  const factory LoginPasswordless({@required String userEmail}) = _$LoginPasswordless;

  String get userEmail;
  $LoginPasswordlessCopyWith<LoginPasswordless> get copyWith;
}

/// @nodoc
abstract class $LoginWithTestUserCopyWith<$Res> {
  factory $LoginWithTestUserCopyWith(
          LoginWithTestUser value, $Res Function(LoginWithTestUser) then) =
      _$LoginWithTestUserCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoginWithTestUserCopyWithImpl<$Res> extends _$LoginEventCopyWithImpl<$Res>
    implements $LoginWithTestUserCopyWith<$Res> {
  _$LoginWithTestUserCopyWithImpl(LoginWithTestUser _value, $Res Function(LoginWithTestUser) _then)
      : super(_value, (v) => _then(v as LoginWithTestUser));

  @override
  LoginWithTestUser get _value => super._value as LoginWithTestUser;
}

/// @nodoc
class _$LoginWithTestUser with DiagnosticableTreeMixin implements LoginWithTestUser {
  const _$LoginWithTestUser();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LoginEvent.loginWithTestUser()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'LoginEvent.loginWithTestUser'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is LoginWithTestUser);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult loginWithGoogle(),
    @required TResult loginWithApple(),
    @required TResult loginPasswordless(String userEmail),
    @required TResult loginWithTestUser(),
    @required TResult loginWithTestUserTwo(),
    @required TResult loginWithTestUserAdmin(),
    @required TResult loginWithTestUserMaster(),
  }) {
    assert(loginWithGoogle != null);
    assert(loginWithApple != null);
    assert(loginPasswordless != null);
    assert(loginWithTestUser != null);
    assert(loginWithTestUserTwo != null);
    assert(loginWithTestUserAdmin != null);
    assert(loginWithTestUserMaster != null);
    return loginWithTestUser();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult loginWithGoogle(),
    TResult loginWithApple(),
    TResult loginPasswordless(String userEmail),
    TResult loginWithTestUser(),
    TResult loginWithTestUserTwo(),
    TResult loginWithTestUserAdmin(),
    TResult loginWithTestUserMaster(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loginWithTestUser != null) {
      return loginWithTestUser();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult loginWithGoogle(LoginWithGoogle value),
    @required TResult loginWithApple(LoginWithApple value),
    @required TResult loginPasswordless(LoginPasswordless value),
    @required TResult loginWithTestUser(LoginWithTestUser value),
    @required TResult loginWithTestUserTwo(LoginWithTestUserTwo value),
    @required TResult loginWithTestUserAdmin(LoginWithTestUserAdmin value),
    @required TResult loginWithTestUserMaster(LoginWithTestUserMaster value),
  }) {
    assert(loginWithGoogle != null);
    assert(loginWithApple != null);
    assert(loginPasswordless != null);
    assert(loginWithTestUser != null);
    assert(loginWithTestUserTwo != null);
    assert(loginWithTestUserAdmin != null);
    assert(loginWithTestUserMaster != null);
    return loginWithTestUser(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult loginWithGoogle(LoginWithGoogle value),
    TResult loginWithApple(LoginWithApple value),
    TResult loginPasswordless(LoginPasswordless value),
    TResult loginWithTestUser(LoginWithTestUser value),
    TResult loginWithTestUserTwo(LoginWithTestUserTwo value),
    TResult loginWithTestUserAdmin(LoginWithTestUserAdmin value),
    TResult loginWithTestUserMaster(LoginWithTestUserMaster value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loginWithTestUser != null) {
      return loginWithTestUser(this);
    }
    return orElse();
  }
}

abstract class LoginWithTestUser implements LoginEvent {
  const factory LoginWithTestUser() = _$LoginWithTestUser;
}

/// @nodoc
abstract class $LoginWithTestUserTwoCopyWith<$Res> {
  factory $LoginWithTestUserTwoCopyWith(
          LoginWithTestUserTwo value, $Res Function(LoginWithTestUserTwo) then) =
      _$LoginWithTestUserTwoCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoginWithTestUserTwoCopyWithImpl<$Res> extends _$LoginEventCopyWithImpl<$Res>
    implements $LoginWithTestUserTwoCopyWith<$Res> {
  _$LoginWithTestUserTwoCopyWithImpl(
      LoginWithTestUserTwo _value, $Res Function(LoginWithTestUserTwo) _then)
      : super(_value, (v) => _then(v as LoginWithTestUserTwo));

  @override
  LoginWithTestUserTwo get _value => super._value as LoginWithTestUserTwo;
}

/// @nodoc
class _$LoginWithTestUserTwo with DiagnosticableTreeMixin implements LoginWithTestUserTwo {
  const _$LoginWithTestUserTwo();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LoginEvent.loginWithTestUserTwo()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'LoginEvent.loginWithTestUserTwo'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is LoginWithTestUserTwo);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult loginWithGoogle(),
    @required TResult loginWithApple(),
    @required TResult loginPasswordless(String userEmail),
    @required TResult loginWithTestUser(),
    @required TResult loginWithTestUserTwo(),
    @required TResult loginWithTestUserAdmin(),
    @required TResult loginWithTestUserMaster(),
  }) {
    assert(loginWithGoogle != null);
    assert(loginWithApple != null);
    assert(loginPasswordless != null);
    assert(loginWithTestUser != null);
    assert(loginWithTestUserTwo != null);
    assert(loginWithTestUserAdmin != null);
    assert(loginWithTestUserMaster != null);
    return loginWithTestUserTwo();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult loginWithGoogle(),
    TResult loginWithApple(),
    TResult loginPasswordless(String userEmail),
    TResult loginWithTestUser(),
    TResult loginWithTestUserTwo(),
    TResult loginWithTestUserAdmin(),
    TResult loginWithTestUserMaster(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loginWithTestUserTwo != null) {
      return loginWithTestUserTwo();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult loginWithGoogle(LoginWithGoogle value),
    @required TResult loginWithApple(LoginWithApple value),
    @required TResult loginPasswordless(LoginPasswordless value),
    @required TResult loginWithTestUser(LoginWithTestUser value),
    @required TResult loginWithTestUserTwo(LoginWithTestUserTwo value),
    @required TResult loginWithTestUserAdmin(LoginWithTestUserAdmin value),
    @required TResult loginWithTestUserMaster(LoginWithTestUserMaster value),
  }) {
    assert(loginWithGoogle != null);
    assert(loginWithApple != null);
    assert(loginPasswordless != null);
    assert(loginWithTestUser != null);
    assert(loginWithTestUserTwo != null);
    assert(loginWithTestUserAdmin != null);
    assert(loginWithTestUserMaster != null);
    return loginWithTestUserTwo(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult loginWithGoogle(LoginWithGoogle value),
    TResult loginWithApple(LoginWithApple value),
    TResult loginPasswordless(LoginPasswordless value),
    TResult loginWithTestUser(LoginWithTestUser value),
    TResult loginWithTestUserTwo(LoginWithTestUserTwo value),
    TResult loginWithTestUserAdmin(LoginWithTestUserAdmin value),
    TResult loginWithTestUserMaster(LoginWithTestUserMaster value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loginWithTestUserTwo != null) {
      return loginWithTestUserTwo(this);
    }
    return orElse();
  }
}

abstract class LoginWithTestUserTwo implements LoginEvent {
  const factory LoginWithTestUserTwo() = _$LoginWithTestUserTwo;
}

/// @nodoc
abstract class $LoginWithTestUserAdminCopyWith<$Res> {
  factory $LoginWithTestUserAdminCopyWith(
          LoginWithTestUserAdmin value, $Res Function(LoginWithTestUserAdmin) then) =
      _$LoginWithTestUserAdminCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoginWithTestUserAdminCopyWithImpl<$Res> extends _$LoginEventCopyWithImpl<$Res>
    implements $LoginWithTestUserAdminCopyWith<$Res> {
  _$LoginWithTestUserAdminCopyWithImpl(
      LoginWithTestUserAdmin _value, $Res Function(LoginWithTestUserAdmin) _then)
      : super(_value, (v) => _then(v as LoginWithTestUserAdmin));

  @override
  LoginWithTestUserAdmin get _value => super._value as LoginWithTestUserAdmin;
}

/// @nodoc
class _$LoginWithTestUserAdmin with DiagnosticableTreeMixin implements LoginWithTestUserAdmin {
  const _$LoginWithTestUserAdmin();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LoginEvent.loginWithTestUserAdmin()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'LoginEvent.loginWithTestUserAdmin'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is LoginWithTestUserAdmin);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult loginWithGoogle(),
    @required TResult loginWithApple(),
    @required TResult loginPasswordless(String userEmail),
    @required TResult loginWithTestUser(),
    @required TResult loginWithTestUserTwo(),
    @required TResult loginWithTestUserAdmin(),
    @required TResult loginWithTestUserMaster(),
  }) {
    assert(loginWithGoogle != null);
    assert(loginWithApple != null);
    assert(loginPasswordless != null);
    assert(loginWithTestUser != null);
    assert(loginWithTestUserTwo != null);
    assert(loginWithTestUserAdmin != null);
    assert(loginWithTestUserMaster != null);
    return loginWithTestUserAdmin();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult loginWithGoogle(),
    TResult loginWithApple(),
    TResult loginPasswordless(String userEmail),
    TResult loginWithTestUser(),
    TResult loginWithTestUserTwo(),
    TResult loginWithTestUserAdmin(),
    TResult loginWithTestUserMaster(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loginWithTestUserAdmin != null) {
      return loginWithTestUserAdmin();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult loginWithGoogle(LoginWithGoogle value),
    @required TResult loginWithApple(LoginWithApple value),
    @required TResult loginPasswordless(LoginPasswordless value),
    @required TResult loginWithTestUser(LoginWithTestUser value),
    @required TResult loginWithTestUserTwo(LoginWithTestUserTwo value),
    @required TResult loginWithTestUserAdmin(LoginWithTestUserAdmin value),
    @required TResult loginWithTestUserMaster(LoginWithTestUserMaster value),
  }) {
    assert(loginWithGoogle != null);
    assert(loginWithApple != null);
    assert(loginPasswordless != null);
    assert(loginWithTestUser != null);
    assert(loginWithTestUserTwo != null);
    assert(loginWithTestUserAdmin != null);
    assert(loginWithTestUserMaster != null);
    return loginWithTestUserAdmin(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult loginWithGoogle(LoginWithGoogle value),
    TResult loginWithApple(LoginWithApple value),
    TResult loginPasswordless(LoginPasswordless value),
    TResult loginWithTestUser(LoginWithTestUser value),
    TResult loginWithTestUserTwo(LoginWithTestUserTwo value),
    TResult loginWithTestUserAdmin(LoginWithTestUserAdmin value),
    TResult loginWithTestUserMaster(LoginWithTestUserMaster value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loginWithTestUserAdmin != null) {
      return loginWithTestUserAdmin(this);
    }
    return orElse();
  }
}

abstract class LoginWithTestUserAdmin implements LoginEvent {
  const factory LoginWithTestUserAdmin() = _$LoginWithTestUserAdmin;
}

/// @nodoc
abstract class $LoginWithTestUserMasterCopyWith<$Res> {
  factory $LoginWithTestUserMasterCopyWith(
          LoginWithTestUserMaster value, $Res Function(LoginWithTestUserMaster) then) =
      _$LoginWithTestUserMasterCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoginWithTestUserMasterCopyWithImpl<$Res> extends _$LoginEventCopyWithImpl<$Res>
    implements $LoginWithTestUserMasterCopyWith<$Res> {
  _$LoginWithTestUserMasterCopyWithImpl(
      LoginWithTestUserMaster _value, $Res Function(LoginWithTestUserMaster) _then)
      : super(_value, (v) => _then(v as LoginWithTestUserMaster));

  @override
  LoginWithTestUserMaster get _value => super._value as LoginWithTestUserMaster;
}

/// @nodoc
class _$LoginWithTestUserMaster with DiagnosticableTreeMixin implements LoginWithTestUserMaster {
  const _$LoginWithTestUserMaster();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LoginEvent.loginWithTestUserMaster()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'LoginEvent.loginWithTestUserMaster'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is LoginWithTestUserMaster);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult loginWithGoogle(),
    @required TResult loginWithApple(),
    @required TResult loginPasswordless(String userEmail),
    @required TResult loginWithTestUser(),
    @required TResult loginWithTestUserTwo(),
    @required TResult loginWithTestUserAdmin(),
    @required TResult loginWithTestUserMaster(),
  }) {
    assert(loginWithGoogle != null);
    assert(loginWithApple != null);
    assert(loginPasswordless != null);
    assert(loginWithTestUser != null);
    assert(loginWithTestUserTwo != null);
    assert(loginWithTestUserAdmin != null);
    assert(loginWithTestUserMaster != null);
    return loginWithTestUserMaster();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult loginWithGoogle(),
    TResult loginWithApple(),
    TResult loginPasswordless(String userEmail),
    TResult loginWithTestUser(),
    TResult loginWithTestUserTwo(),
    TResult loginWithTestUserAdmin(),
    TResult loginWithTestUserMaster(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loginWithTestUserMaster != null) {
      return loginWithTestUserMaster();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult loginWithGoogle(LoginWithGoogle value),
    @required TResult loginWithApple(LoginWithApple value),
    @required TResult loginPasswordless(LoginPasswordless value),
    @required TResult loginWithTestUser(LoginWithTestUser value),
    @required TResult loginWithTestUserTwo(LoginWithTestUserTwo value),
    @required TResult loginWithTestUserAdmin(LoginWithTestUserAdmin value),
    @required TResult loginWithTestUserMaster(LoginWithTestUserMaster value),
  }) {
    assert(loginWithGoogle != null);
    assert(loginWithApple != null);
    assert(loginPasswordless != null);
    assert(loginWithTestUser != null);
    assert(loginWithTestUserTwo != null);
    assert(loginWithTestUserAdmin != null);
    assert(loginWithTestUserMaster != null);
    return loginWithTestUserMaster(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult loginWithGoogle(LoginWithGoogle value),
    TResult loginWithApple(LoginWithApple value),
    TResult loginPasswordless(LoginPasswordless value),
    TResult loginWithTestUser(LoginWithTestUser value),
    TResult loginWithTestUserTwo(LoginWithTestUserTwo value),
    TResult loginWithTestUserAdmin(LoginWithTestUserAdmin value),
    TResult loginWithTestUserMaster(LoginWithTestUserMaster value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loginWithTestUserMaster != null) {
      return loginWithTestUserMaster(this);
    }
    return orElse();
  }
}

abstract class LoginWithTestUserMaster implements LoginEvent {
  const factory LoginWithTestUserMaster() = _$LoginWithTestUserMaster;
}
